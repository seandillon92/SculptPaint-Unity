#pragma kernel Update
#pragma enable_d3d11_debug_symbols
#include "UnityCG.cginc"

RWByteAddressBuffer vertices;
uint stride;
uint size;

uint offset_pos;
uint offset_norm;
uint offset_tangent;

uint iteration_offset;
uint iteration;

float4x4 mvp;
float2 mousePos;
float aspect;
float brushSize;
float maxDeformation;

float3 direction;

// 0 - World
// 1 - Local
// 2 - Normal
uint space;

Texture2D brushTexture;
SamplerState linearClamp;

[numthreads(1, 1, 1)]
void Update (uint3 id : SV_DispatchThreadID) {

    // Fetch the current vertex position
    uint index = id.x + iteration * iteration_offset;

    uint offset = index * stride + offset_pos;
    uint x = vertices.Load(offset);
    uint y = vertices.Load(offset + size);
    uint z = vertices.Load(offset + size* 2);

    float4 vertex;
    vertex.x = asfloat(x);
    vertex.y = asfloat(y);
    vertex.z = asfloat(z);
    vertex.w = 1.0f;


    float4 projected = ComputeScreenPos(mul(mvp, vertex));
    projected.xyz /= projected.w;

    float2 distance = mousePos - projected.xy;
    distance.x *= aspect;

    float2 coords = distance * brushSize + float2(0.5, 0.5);
    float w = brushTexture.SampleLevel(linearClamp, coords, 0, 0).a;

    if (space == 2) //normal space
    {
        uint offset = index * stride + offset_norm;
        float3 normal;
        normal.x = asfloat(vertices.Load(offset));
        normal.y = asfloat(vertices.Load(offset + size));
        normal.z = asfloat(vertices.Load(offset + size * 2));

        float3 tangent;
        
        offset = index * stride + offset_tangent;
        tangent.x = asfloat(vertices.Load(offset));
        tangent.y = asfloat(vertices.Load(offset + size));
        tangent.z = asfloat(vertices.Load(offset + size * 2));

        float3 bitangent = cross(normal, tangent);

        direction = tangent * direction.x + normal * direction.y + bitangent * direction.z;
    }

    // Modify the vertex position
    vertex.xyz += direction * lerp(0, maxDeformation, w);

    x = asuint(vertex.x);
    y = asuint(vertex.y);
    z = asuint(vertex.z);

    // Write the modified vertex position
    vertices.Store(offset, x);
    vertices.Store(offset + size,y);
    vertices.Store(offset + size * 2, z);
}