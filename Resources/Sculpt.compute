#pragma kernel Update
#pragma enable_d3d11_debug_symbols
#include "UnityCG.cginc"

RWByteAddressBuffer vertices;
uint stride;
uint size;

uint offset_pos;
uint offset_norm;
uint offset_tangent;

uint iteration_offset;
uint iteration;

float4x4 model;
float3 position;
float3 tangent;
float3 bitangent;
float radius;

float maxDeformation;

float3 direction;

// 0 - World
// 1 - Local
// 2 - Normal
uint space;

Texture2D brushTexture;
SamplerState linearClamp;

float3 project(float3 a, float3 b) {
    return b * (dot(a, b) / dot(b, b));
}

[numthreads(1, 1, 1)]
void Update (uint3 id : SV_DispatchThreadID) {

    // Fetch the current vertex position
    uint index = id.x + iteration * iteration_offset;

    uint offset = index * stride + offset_pos;
    uint x = vertices.Load(offset);
    uint y = vertices.Load(offset + size);
    uint z = vertices.Load(offset + size* 2);

    float4 vertex;
    vertex.x = asfloat(x);
    vertex.y = asfloat(y);
    vertex.z = asfloat(z);
    vertex.w = 1.0f;

    float3 worldPosition = mul(model, vertex);

    float3 diff = (position - worldPosition) * radius;
    float3 tangentProj = project(diff, tangent);
    float3 bitangentProj = project(diff, bitangent);
    float2 uv = float2(-dot(tangent, tangentProj), -dot(bitangent, bitangentProj)) + float2(0.5, 0.5);
    if (uv.x > 1 || uv.y > 1 || uv.x < 0 || uv.y < 0) {
        return;
    }

    float w = brushTexture.SampleLevel(linearClamp, uv, 0, 0).a;

    if (space == 2) //normal space
    {
        uint offset = index * stride + offset_norm;
        float3 normal;
        normal.x = asfloat(vertices.Load(offset));
        normal.y = asfloat(vertices.Load(offset + size));
        normal.z = asfloat(vertices.Load(offset + size * 2));

        float3 tangent;
        
        offset = index * stride + offset_tangent;
        tangent.x = asfloat(vertices.Load(offset));
        tangent.y = asfloat(vertices.Load(offset + size));
        tangent.z = asfloat(vertices.Load(offset + size * 2));

        float3 bitangent = cross(normal, tangent);

        direction = tangent * direction.x + normal * direction.y + bitangent * direction.z;
    }

    // Modify the vertex position
    vertex.xyz += direction * lerp(0, maxDeformation, w);

    x = asuint(vertex.x);
    y = asuint(vertex.y);
    z = asuint(vertex.z);

    // Write the modified vertex position
    vertices.Store(offset, x);
    vertices.Store(offset + size,y);
    vertices.Store(offset + size * 2, z);
}